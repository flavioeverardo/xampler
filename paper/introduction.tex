\section{Introduction} \label{sec:introduction}
 Parity constraints constitute the foundations of reasoning modes like sampling or (approximate) model counting \cite{DBLP:journals/corr/abs-1806-02239}, as well as circuit verification and cryptography \cite{DBLP:conf/laitinen2014extending}.
 %
 With most of their applications in the neighboring area of Satisfiability Testing (SAT) \cite{DBLP:journals/corr/abs-1806-02239},
 almost no attention has so far been paid to their integration into Answer Set Programming (ASP).%~\cite{kalepesc16a}.
 
 Previous efforts represented parity constraints into ASP in three ways,
 via the \texttt{\#count} aggregate coupled with a modulo-two operation as used or sampling in the initial prototype of \xorro{} from 2009\footnote{https://sourceforge.net/p/potassco/code/HEAD/tree/branches/xorro},
 as lists, as shown in \emph{harvey}~\cite{DBLP:conf/lpnmr/GresslerOT17},
 and as the (discontinued) aggregates \texttt{\#even} and \texttt{\#odd} from \gringo{} series 3 via meta-encodings.
 %
 Unlike these approaches, several SAT solvers feature rather sophisticated treatments of parity constraints.
 For instance, most popularly the award-winning solver \cryptominisat~\cite{DBLP:conf/sat/SoosNC09}, which pursues a hybrid approach,
 addressing parity constraints separately with Gauss-Jordan Elimination (GJE).
 
 To this end, we present the next generation of \xorro,~\cite{DBLP:conf/lpnmr/EverardoJKS19}
 implementing six alternatives to handle parity constraints into ASP,
 benefiting from the advanced interfaces of \clingo{},
 and the sophisticated solving techniques developed in SAT.
 %
 We propose two types of approaches, eager and lazy.~\footnote{Both eager and lazy follows the methodology from Satisfiability modulo theories.}
 The former relies on ASP encodings of parity constraints, and the latter uses theory propagators within \clingo{}’s Python interface~\cite{DBLP:conf/iclp/GebserKKOSW16}.
 
 To accommodate parity constraints in the input language,
 we rely on \clingo’s theory language extension~\cite{DBLP:conf/iclp/GebserKKOSW16}
 following the common syntax of \emph{aggregates}~\cite{DBLP:journals/tplp/GebserHKLS15}:
 
 %
 % ------------------------------------------------------------------------------
 \lstinputlisting[basicstyle=\small\ttfamily]{listings/xor_constraints_ex1.lp}
 % ------------------------------------------------------------------------------
 %
 That is, \xorro{} extends the input language of \clingo{} by
 aggregate names \texttt{\&even} and \texttt{\&odd} that are followed
 by a set, whose elements are \emph{terms} conditioned by
 conjunctions of literals separated by commas.%
 %
 \footnote{In turn, multiple conditional terms within an aggregate are
 	separated by semicolons.}
 %
 In the context of a choice rule \texttt{\set{p(1..3)}.}, the parity constraints shown above
 amounts to the \XOR{} operations: \\
 $p(1) \xor \bot$ and $p(2) \xor p(3) \xor \top$
 (where $\bot$ and $\top$ stand for the Boolean constants true and false, respectively)
 yielding the answer sets~\texttt{\set{p(1)}} and \texttt{\set{p(1),p(2),p(3)}}.
 
 
 %The semantics of aggregates formed with keywords \texttt{\&even} and
 %\texttt{\&odd} is defined by \emph{even} and \emph{odd} parity constraints,
 %respectively.
 %In this implementation,
 Currently, these constraints are interpreted as directives,
 filtering answer sets that do not satisfy the parity constraint in question.
 \footnote{For now, parity constraints may not occur in the bodies nor the heads of rules.}
 %
 Hence, the first
 constraint filters out answer sets not containing the atom
 \texttt{p(1)}, while the second requires that either none or both of
 the atoms \texttt{p(2)} and \texttt{p(3)} are included.
 
 %As mentioned, \xorro{} handles parity constraints in six ways as shown in Table \ref{table:xorro_approaches},
 %implements different means to handle parity constraints as shown in Table \ref{table:xorro_approaches},
 %where the first three corresponds to the eager, and the last three to the lazy approaches.
 Table~ \ref{table:xorro_approaches}, shows the six implementations to handle parity constraints.
 The first three corresponds to the eager, and the last three to the lazy approaches. 
 
 \begin{table*}[t]
% 	\centering
\caption{\xorro{} approaches to handle parity constraints}\label{table:xorro_approaches}
 	%\vspace{-5mm}
 	\begin{tabular}{ l|l }
 		Approach  & Description  \\
 		\hline\hline
 		count     & Add count aggregates with a modulo 2 operation  \\  
 		list,tree & Translate binary \XOR{} operators into rules forming list and tree structures \\
 		%            & (binary operators are arranged in list/tree)\\
 		countp    & Propagator simply counting truth literals on total assignments\\
 		up        & Propagator implementing unit propagation\\
 		gje       & Propagator implementing (non-incremental) Gauss-Jordan Elimination
 		
 	\end{tabular}
 %	\vspace{-7mm}
\end{table*}
 %
 Finally, we empirically evaluate the different approaches in view of their impact on solving performance,
 while varying the number and size of parity constraints compared against \clingo{} solving time.
 %
 The experiments show that \xorro{} scales depending on the combination of the number, density, and preprocessing of the parity constraints.
 %
 When increasing the number of high-density constraints as used in sampling (\XOR{}s with a size of half the program variables), we start to see that the solving time increases concerning \clingo.
 %
 Comparing to previous approaches, the eager counting, and the list (from the previous \xorro{} and \emph{harvey}), both stay behind for sampling purposes. Their scalability is subjected to the density of the parity constraints and preprocessing, and particularly, grounding becomes the bottleneck for the counting approach with aggregates.