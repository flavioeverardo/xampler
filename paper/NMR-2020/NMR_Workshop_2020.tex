%%%% kr-instructions.tex -- version 1.2 (27-Feb-2020)

\typeout{KR2020 Instructions for Authors}

% These are the instructions for authors for KR-20.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
%\usepackage{algorithm}
%\usepackage{algorithmic}
\urlstyle{same}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}

% added by Ankit
\usepackage{xspace}
\def\approxmc{\textsf{ApproxMC}\xspace}
\def\approxasc{\textsf{ApproxASC}\xspace}
\def\asp{\textsf{\#ASP}\xspace}
\newtheorem{definition}{Definition}

% Copied from Flavio draft
\usepackage{url}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{float}
\usepackage{listings}

%\usepackage[ruled,vlined]{algorithm2e}
%\SetKwComment{Comment}{$\triangleright$\ }{}

\newcommand{\XOR}{\textsc{xor}} % just an idea


% - systems ----------------------------------------------------------------------
% >>> NOT USED in BOOK <<<
\newcommand{\sysfont}{\textit}
\newcommand{\acthex}{\sysfont{acthex}}
\newcommand{\adsolver}{\sysfont{adsolver}}
\newcommand{\anthem}{\sysfont{anthem}}
\newcommand{\asparagus}{\sysfont{asparagus}}
\newcommand{\aspartame}{\sysfont{aspartame}}
\newcommand{\aspic}{\sysfont{aspic}}
\newcommand{\aspcud}{\sysfont{aspcud}}
\newcommand{\aspmt}{\sysfont{aspmt}}
\newcommand{\asprilo}{\sysfont{asprilo}}
\newcommand{\asprin}{\sysfont{asprin}}
\newcommand{\assat}{\sysfont{assat}}
\newcommand{\berkmin}{\sysfont{berkmin}}
\newcommand{\chuffed}{\sysfont{chuffed}}
\newcommand{\chasp}{\sysfont{chasp}}
\newcommand{\claspD}{\sysfont{claspD}}
\newcommand{\claspar}{\sysfont{claspar}}
\newcommand{\claspfolio}{\sysfont{claspfolio}}
\newcommand{\clasp}{\sysfont{clasp}}
\newcommand{\claspre}{\sysfont{claspre}}
\newcommand{\clingcon}{\sysfont{clingcon}}
\newcommand{\clingo}{\sysfont{clingo}}
\newcommand{\clingod}[1]{\clingo\textnormal{[}\textsc{#1}\textnormal{]}}
\newcommand{\cmodels}{\sysfont{cmodels}}
\newcommand{\coala}{\sysfont{coala}}
\newcommand{\cplex}{\sysfont{cplex}}
\newcommand{\dingo}{\sysfont{dingo}}
\newcommand{\dflat}{\sysfont{dflat}}
\newcommand{\dlvhex}{\sysfont{dlvhex}}
\newcommand{\dlv}{\sysfont{dlv}}
\newcommand{\ezcsp}{\sysfont{ezcsp}}
\newcommand{\ezsmt}{\sysfont{ezsmt}}
\newcommand{\embasp}{\sysfont{embasp}}
\newcommand{\fastdownward}{\sysfont{fastdownward}}
\newcommand{\ftolp}{\sysfont{f2lp}}
\newcommand{\gasp}{\sysfont{gasp}}
\newcommand{\gfd}{\sysfont{g12fd}}
\newcommand{\gecode}{\sysfont{gecode}}
\newcommand{\gidl}{\sysfont{gidl}}
\newcommand{\gnt}{\sysfont{gnt}}
\newcommand{\gringo}{\sysfont{gringo}}
\newcommand{\harvey}{\sysfont{harvey}}
\newcommand{\iclingo}{\sysfont{iclingo}}
\newcommand{\idp}{\sysfont{idp}}
\newcommand{\inca}{\sysfont{inca}}
\newcommand{\jdlv}{\sysfont{jdlv}}
\newcommand{\lctocasp}{\sysfont{lc2casp}}
\newcommand{\lparse}{\sysfont{lparse}}
\newcommand{\lpsolve}{\sysfont{lpsolve}}
\newcommand{\lptodiff}{\sysfont{lp2diff}}
\newcommand{\lptosat}{\sysfont{lp2sat}}
\newcommand{\mchaff}{\sysfont{mchaff}}
\newcommand{\measp}{\sysfont{measp}}
\newcommand{\metasp}{\sysfont{metasp}}
\newcommand{\mingo}{\sysfont{mingo}}
\newcommand{\minisat}{\sysfont{minisat}}
\newcommand{\minisatid}{\sysfont{minisatid}}
\newcommand{\minizinc}{\sysfont{minizinc}}
\newcommand{\mznfzn}{\sysfont{mzn2fzn}}
\newcommand{\nomorepp}{\sysfont{nomore++}}
\newcommand{\oclingo}{\sysfont{oclingo}}
\newcommand{\omiga}{\sysfont{omiga}}
\newcommand{\piclasp}{\sysfont{piclasp}}
\newcommand{\picosat}{\sysfont{picosat}}
\newcommand{\picat}{\sysfont{picat}}
\newcommand{\picatsat}{\sysfont{picatsat}}
\newcommand{\plasp}{\sysfont{plasp}}
\newcommand{\quontroller}{\sysfont{quontroller}}
\newcommand{\reify}{\sysfont{reify}}
\newcommand{\rosoclingo}{\sysfont{rosoclingo}}
\newcommand{\sag}{\sysfont{sag}}
\newcommand{\satz}{\sysfont{satz}}
\newcommand{\siege}{\sysfont{siege}}
\newcommand{\smac}{\sysfont{smac}}
\newcommand{\smodelscc}{\sysfont{smodels$_{\!cc}$}}
\newcommand{\smodelsr}{\sysfont{smodels}$_r$}
\newcommand{\smodels}{\sysfont{smodels}}
\newcommand{\sugar}{\sysfont{sugar}}
\newcommand{\teaspoon}{\sysfont{teaspoon}}
\newcommand{\tel}{\sysfont{tel}}
\newcommand{\telingo}{\sysfont{telingo}}
\newcommand{\unclasp}{\sysfont{unclasp}}
\newcommand{\wasp}{\sysfont{wasp}}
\newcommand{\xorro}{\sysfont{xorro}}
\newcommand{\zchaff}{\sysfont{zchaff}}
\newcommand{\zzz}{\sysfont{z3}}
\newcommand{\cryptominisat}{\sysfont{crypto-minisat}}

\newcommand{\clingoM}[1]{\clingo{\small\textnormal{[}\textsc{#1}\textnormal{]}}}
\newcommand{\ASPm}[1]{ASP\raisebox{.7pt}{[\textsc{#1}]}}

\newcommand{\flatzinc}{\sysfont{FlatZinc}}
\newcommand{\aspif}{\sysfont{aspif}}

\newcommand{\python}{Python}
\newcommand{\lua}{Lua}
\newcommand{\cpp}{C++}
\newcommand{\C}{C}
\newcommand{\java}{Java}
\newcommand{\haskell}{Haskell}

\newcommand{\el}[1]{\vspace{#1\baselineskip}}

% Some notational macros

\newcommand{\rg}[3]{{#1}{#2}\,\ldots{#2}\,{#3}}
\newcommand{\xor}{\oplus}
\newcommand{\true}{\top}
\newcommand{\false}{\bot}
\newcommand{\naf}{\mathit{not}\,}
\newcommand{\set}[1]{\{#1\}}

% Tomi's specialties (not needed in the end)

\newcommand{\TODO}[1]{%
	\vspace{1\baselineskip}\noindent\hrulefill\hspace{1em}{#1}%
	\hspace{1em}\hrulefill\vspace{1\baselineskip}}

\newcommand{\DONE}{%
	\vspace{1\baselineskip}\noindent\hrule\vspace{1\baselineskip}}

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.

\title{An Approximate Model Counter for ASP}

% Single author syntax
\iffalse % (remove the multiple-author syntax below and \iffalse ... \fi here)
\author{%
    Author name
    \affiliations
    Affiliation
    \emails
    email@example.com    % email
}
\fi
% Multiple author syntax
\author{%
Flavio Everardo$^1$\and
Markus Hecher$^2$\and
Ankit Shukla$^{3}$
\affiliations
$^1$ University of Potsdam, Germany\\
$^2$ TU Wien, Vienna, Austria\\
$^3$ JKU, Linz, Austria\\
\emails
flavio.everardo@cs.uni-potsdam.de,
mhecher@gmail.com,
ankit.shukla@jku.at
}

\begin{document}

\maketitle

\begin{abstract}
(\asp) XXX
\end{abstract}

\section{Introduction} \label{sec:introduction}
%
Answer Set Programming (ASP)~\cite{Lifschitz99,BrewkaEiterTruszczynski11,GebserKaminskiKaufmannSchaub12} is a 
problem modeling and solving framework that is well-known in the area 
of knowledge representation and reasoning and artificial intelligence. 
%
This framework has been practically applied for several 
problems~\cite{BalducciniGelfondNogueira06a,NiemelaSimonsSoininen99,NogueiraBalducciniGelfond01a,GuziolowskiEtAl13a,SchaubWoltran18}.
%

Recently, there has been growing interest for counting solutions of problems.
%
Indeed, counting solutions is a well-known task not only in mathematics and computer
science, but also in other
areas~\cite{ChakrabortyMeelVardi16a,DomshlakHoffmann07a,GomesKautzSabharwalSelman08a,SangBeameKautz05a}.
%
%
%
Examples cover also applications in machine learning and probabilistic inference~\cite{ChaviraDarwiche08a}.
%
%
In terms of computational complexity, counting has been well-studied since the
late
70s~\cite{DurandHermannKolaitis05,HemaspaandraVollmer95a,Valiant79,Valiant79b}.
%
There are also results for counting involving projection, where one wants to
count only with respect to a given set of projection atoms,
which has been established for logic~\cite{AzizChuMuise15a,CapelliMengel19,FichteEtAl18,LagniezMarquis19a,GuptaSharmaRoy19a,SharmaRoySoos19a},
reliability estimation~\cite{MeelEtAl17a} as well as
answer set programming~\cite{GebserKaufmannSchaub09a,Aziz15a,FichteHecher19}.
%

Given that in general counting answer sets is rather hard, namely ${\#\cdot\text{coNP}}$-complete~\cite{FichteEtAl17,DurandHermannKolaitis05}, which further increases
to ${\#\cdot\Sigma_2^P}$-completeness~\cite{FichteHecher19} if counting with respect to a projection,
a different approach than exact counting seems to be required in practice.
%
Indeed, such approaches were successful for propositional logic (SAT), where reasoning modes like sampling (near-uniform generation)
or (approximate) model counting~\cite{gosase07a,gohosase07b,chmeva13a,chmeva13b,soomee19a}
were studied.
%
For this purpose, so-called parity constraints  (\XOR{} constraints) are used specifically to partition the search space in parts that preferably are of roughly the same size.

Parity constraints have been recently accommodated in ASP
as the fundamental part of the system \xorro{}~\cite{DBLP:conf/lpnmr/EverardoJKS19}.
% 
With different solving approaches over parity constraints in \xorro{}, these constraints amount to the classical \XOR{} operator following the aggregates-like syntax by means of theory atoms.
They are interpreted as directives, solved on top of an ASP program acting as answer sets filters that do not satisfy the parity constraint in question.
%
%Currently, these parity constraints may not occur in the bodies nor the heads of rules.



%Parity constraints constitute the foundations of reasoning modes like sampling or (approximate) model counting \cite{DBLP:journals/corr/abs-1806-02239}, as well as circuit verification and cryptography \cite{DBLP:conf/laitinen2014extending}.
%
With most of the applications of \XOR{} constraints in the neighboring area of SAT~\cite{DBLP:journals/corr/abs-1806-02239},
only few attention has been paid to treat parity constraints as well as reasoning modes like sampling or model counting for ASP. %~\cite{kalepesc16a}.
%
To this end, we present an extension to \xorro{} towards counting answer sets following the work from~\cite{DBLP:conf/cp/ChakrabortyMV13}
benefiting from the advanced interfaces of \clingo{},
and the sophisticated solving techniques developed in SAT~(e.g. the award-winning solver \cryptominisat~\cite{DBLP:conf/sat/SoosNC09}).
%
This paper is structured in ...

\section{Parity Constraints, \emph{xorro}, and Search Space Partition} \label{sec:hashing}

Towards the definition of parity aggregates, let $\true$ and $\false$
stand for the Boolean constants \emph{true} and \emph{false},
respectively, and a literal is an atom $a$ and its negation $\neg a$.
\footnote{In the context of ASP, we understand the negation $\neg$ as the default negation.}

To accommodate parity constraints in ASP's input language,
we rely on \clingo’s theory language extension~\cite{DBLP:conf/iclp/GebserKKOSW16}
following the common syntax of \emph{aggregates}~\cite{DBLP:journals/tplp/GebserHKLS15}:

%
\begin{verbatim}
&odd{ 1 : p(1) }.
&even{ X : p(X), X>1 }.
\end{verbatim}

%
That is, \xorro{} extends the input language of \clingo{} by
aggregate names \texttt{\&even} and \texttt{\&odd} that are followed
by a set, whose elements are \emph{terms} conditioned by
conjunctions of literals separated by commas.%
%
\footnote{In turn, multiple conditional terms within an aggregate are
	separated by semicolons.}
%
In the context of a choice rule \texttt{\set{p(1..3)}.}, the parity constraints shown above
amounts to the \XOR{} operations: \\
$p(1) \xor \bot$ and $p(2) \xor p(3) \xor \top$
(where $\bot$ and $\top$ stand for the Boolean constants true and false, respectively)
yielding the answer sets~\texttt{\set{p(1)}} and \texttt{\set{p(1),p(2),p(3)}}.


%The semantics of aggregates formed with keywords \texttt{\&even} and
%\texttt{\&odd} is defined by \emph{even} and \emph{odd} parity constraints,
%respectively.
%In this implementation,
Currently, these constraints are interpreted as directives,
filtering answer sets that do not satisfy the parity constraint in question.
\footnote{For now, parity constraints may not occur in the bodies nor the heads of rules.}
%
Hence, the first
constraint filters out answer sets not containing the atom
\texttt{p(1)}, while the second requires that either none or both of
the atoms \texttt{p(2)} and \texttt{p(3)} are included.

%As mentioned, \xorro{} handles parity constraints in six ways as shown in Table \ref{table:xorro_approaches},
%implements different means to handle parity constraints as shown in Table \ref{table:xorro_approaches},
%where the first three corresponds to the eager, and the last three to the lazy approaches.
Table~ \ref{table:xorro_approaches}, shows the six implementations to handle parity constraints.
The first three corresponds to the eager, and the last three to the lazy approaches. 

\begin{table*}[t]
	% 	\centering
	\caption{\xorro{} approaches to handle parity constraints}\label{table:xorro_approaches}
	%\vspace{-5mm}
	\begin{tabular}{ l|l }
		Approach  & Description  \\
		\hline\hline
		count     & Add count aggregates with a modulo 2 operation  \\  
		list,tree & Translate binary \XOR{} operators into rules forming list and tree structures \\
		%            & (binary operators are arranged in list/tree)\\
		countp    & Propagator simply counting truth literals on total assignments\\
		up        & Propagator implementing unit propagation\\
		gje       & Propagator implementing (non-incremental) Gauss-Jordan Elimination
		
	\end{tabular}
	%	\vspace{-7mm}
\end{table*}
%
Finally, we empirically evaluate the different approaches in view of their impact on solving performance,
while varying the number and size of parity constraints compared against \clingo{} solving time.
%
The experiments show that \xorro{} scales depending on the combination of the number, density, and preprocessing of the parity constraints.
%
When increasing the number of high-density constraints as used in sampling (\XOR{}s with a size of half the program variables), we start to see that the solving time increases concerning \clingo.
%
Comparing to previous approaches, the eager counting, and the list (from the previous \xorro{} and \emph{harvey}), both stay behind for sampling purposes. Their scalability is subjected to the density of the parity constraints and preprocessing, and particularly, grounding becomes the bottleneck for the counting approach with aggregates.

\section{Hashing and Xor's} \label{sec:hashing}
Apriori we do not know the distribution of the solution set; $Sol(\phi)$. 
%
How to perform a good hashing if we have no knowledge of the distribution of solutions? i.e., how to partition the $Sol(\phi)$ into cells with a roughly equal number of solutions?
%
\textbf{Universal hashing}~\cite{DBLP:conf/stoc/CarterW77} comes to our rescue. 
%
%To partition the $Sol(\phi)$ into roughly equal small cells without knowing the distribution of the solution we use universal hashing. 
The idea is: pick a function randomly from a family of hash functions.  By choosing a random hash function from a family, we randomize over arbitrary input distribution. This guarantees a low number of collisions in expectation irrespective of how data is chosen.
%

\begin{definition}
A family of functions $\mathcal{H}=\{h: U \to [m]\}$  is called a universal family if, 
\[ \forall x,y\in U,~x\neq y:~~\Pr _{h\in H}[h(x)=h(y)]\leq {\frac {1}{m}} \]	
\end{definition}

For model counting with high guarantees this is not enough, we not only need every input to be hash uniformly but also hashed independently. We need a family of $k$-wise independent hash functions~\cite{DBLP:conf/focs/WegmanC79},
%
%$H(n, m, k)$: 
%Need Family of $k$-wise independent hash functions mapping $\{0, 1\}^{U}$
% $\to$ $\{0, 1\}^{m}$ such that every $k$ elements are mapped independently.
formally, 
a family $\mathcal{H} = {h : U \to [m]}$ of hash functions
is $k$-wise independent if:
\begin{enumerate}
	\item For any distinct keys $x_1, ..., x_k \in U$, the hash codes
	$h(x_1), ..., h(x_k)$ are independent random variables.
	\item For any fixed $x$, $h(x)$ is uniformly distributed in [m].
\end{enumerate}

Technical definition generally used for the $k$-wise independent:
% i.e.,  A random hash function $h$ is $k$-independent iffor all choices of distinct $x_1$,…,$x_k$ the values $h(x_1)$,…,$h(x_k)$ are independent.
\begin{definition}
	Let $\mathcal{H}=\{h: U \to [m]\}$ be a family of hash functions. For any distinct $x_1$, . . . , $x_k \in U$ and any $y_1$, ..., $y_k \in [m]$ we have the following guarantee.
	
	$~~\Pr_{h\in H}
	[h(x_1) = y_1 \land ... \land h(x_k) = y_k] = \frac {1}
	{m^
		k}$
\end{definition}

Higher the $k$, stronger will be the guarantee on a range of the size of cells. To encode $k$-wise independence we will require polynomial of degree $k$ - $1$. But higher the $k$, harder it will be to solve the formula with these constraints. Due to this trade-off we just use 3-wise independent. If we use $k$-wise independence, all cells will be  small and we will get a \textbf{uniform generation}. With $3$-wise independence we achieve: \emph{a random cell is small with high probabablity}, also called \textbf{almost-uniform generation}.


The canonical construction of a $k$-wise independent family is based on polynomials
of degree $k$ - $1$. Let $p \geq |U|$ be prime. Picking random $a_0,...,a_{k - 1} \in \{0, . . . , p$-$ 1\}$,
the hash function is defined by:
\[ h(x) = ( ( a_{k-1} x^ {k - 1} + ... + a_1 x + a_0) \,\, mod \,\, p) \,\, mod \,\,  m\]


For $p \gg	 m$, the hash function is statistically close to $k$-wise independent.

The 2-wise independent hash is: 

\[ h(x) = (((a_1 x + a_0) \,\, mod \,\, p) \,\, mod \,\, m ) \]

\section{ApproxASP} \label{approxasp}
\textbf{ApproxMC Algorithm into ASP}

\begin{algorithm}[h]
	\textbf{ApproxASP}($F$, $\epsilon$, $\delta$) \;
	\SetAlgoLined
	\KwResult{Approximate number of answer sets}
	$counter \gets 0$ ; $C \gets emptyList$\;
	$pivot \gets  2 \, \times $ \textbf{ComputeThreshold($\epsilon$)} \;
	$S \gets Xampler(F, pivot + 1)$ // {Solve pivot+1 AS}  \;
	\eIf{ $|S| \leq pivot$}
	{ % Open If
		\textbf{return} $|S|$ 
	} % Close If
	{ % Open Else
		$t \gets $ \textbf{ComputeIterCount($\delta$)} 
		
		\While{$counter < t$}{
			$c \gets $ \textbf{ApproxASPCore($F, pivot$)} \;
			$counter \gets counter + 1$ \;
			\If{$c \neq \bot$}{\textbf{AddToList($C,c$)}}
		} % Close While
	} % Close else
	$finalCount \gets $ \textbf{FindMedian($C$)} \;
	\textbf{return} $finalCount$
	
	\caption{ApproxMC into ASP}
\end{algorithm}


\begin{algorithm}
	\textbf{return} $\lceil 3 e^{1/2} (1 + \frac{1}{\epsilon})^2 \rceil$
	\caption{ComputeThreshold($\epsilon$)}
\end{algorithm}

\begin{algorithm}
	\textbf{return} $\lceil 35 \log_2 (3/\delta) \rceil$
	\caption{ComputeIterCount($\delta$)}
\end{algorithm}

\begin{algorithm}
	/* Assume $z_1 , ..., z_n $ are the varaibles of $F$ */ \\
	$ l \gets \lfloor \log_2 (pivot) - 1 \rfloor$ \\
	$ i \gets l - 1$ \\
	
	\While{($1 \leq |S| \leq pivot $) or ($i = n$)}{
		$ i \gets i + 1$ \\
		Choose $h$ at random from $H_{xor}(n, i - l, 3)$ \\
		Choose $\alpha$ at random from $\{0,1\}^{i-l}$ \\
		$S \gets Xampler(F \land (h(z_1, ..., z_n)=\alpha, pivot + 1)$ %\Comment*[r]{Solve $P \land XOR$}  
	}
	
	\eIf{ $|S|$ $> pivot$ or $|S|$ = 0}
	{\textbf{return} $\bot$}
	{\textbf{return} $|S|$ $\cdot 2^{i-l}$}
	
	
	
	\caption{ApproxASPCore($F, pivot$)}
\end{algorithm}

\section{Conclusion} \label{sec:conclusion}
XXX

%% The file kr.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{kr}
\bibliography{NMR2020}

\end{document}

