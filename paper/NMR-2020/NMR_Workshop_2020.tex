%%%% kr-instructions.tex -- version 1.2 (27-Feb-2020)

\typeout{KR2020 Instructions for Authors}

% These are the instructions for authors for KR-20.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
%\usepackage{algorithm}
%\usepackage{algorithmic}
\urlstyle{same}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}

% added by Ankit
\usepackage{xspace}
\def\approxmc{\textsf{ApproxMC}\xspace}
\def\approxasc{\textsf{ApproxASC}\xspace}
\def\asp{\textsf{\#ASP}\xspace}
\newtheorem{definition}{Definition}

% Copied from Flavio draft
\usepackage{url}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{float}
\usepackage{listings}

%\usepackage[ruled,vlined]{algorithm2e}
%\SetKwComment{Comment}{$\triangleright$\ }{}

\newcommand{\XOR}{\textsc{xor}} % just an idea


% - systems ----------------------------------------------------------------------
% >>> NOT USED in BOOK <<<
\newcommand{\sysfont}{\textit}
\newcommand{\acthex}{\sysfont{acthex}}
\newcommand{\adsolver}{\sysfont{adsolver}}
\newcommand{\anthem}{\sysfont{anthem}}
\newcommand{\asparagus}{\sysfont{asparagus}}
\newcommand{\aspartame}{\sysfont{aspartame}}
\newcommand{\aspic}{\sysfont{aspic}}
\newcommand{\aspcud}{\sysfont{aspcud}}
\newcommand{\aspmt}{\sysfont{aspmt}}
\newcommand{\asprilo}{\sysfont{asprilo}}
\newcommand{\asprin}{\sysfont{asprin}}
\newcommand{\assat}{\sysfont{assat}}
\newcommand{\berkmin}{\sysfont{berkmin}}
\newcommand{\chuffed}{\sysfont{chuffed}}
\newcommand{\chasp}{\sysfont{chasp}}
\newcommand{\claspD}{\sysfont{claspD}}
\newcommand{\claspar}{\sysfont{claspar}}
\newcommand{\claspfolio}{\sysfont{claspfolio}}
\newcommand{\clasp}{\sysfont{clasp}}
\newcommand{\claspre}{\sysfont{claspre}}
\newcommand{\clingcon}{\sysfont{clingcon}}
\newcommand{\clingo}{\sysfont{clingo}}
\newcommand{\clingod}[1]{\clingo\textnormal{[}\textsc{#1}\textnormal{]}}
\newcommand{\cmodels}{\sysfont{cmodels}}
\newcommand{\coala}{\sysfont{coala}}
\newcommand{\cplex}{\sysfont{cplex}}
\newcommand{\dingo}{\sysfont{dingo}}
\newcommand{\dflat}{\sysfont{dflat}}
\newcommand{\dlvhex}{\sysfont{dlvhex}}
\newcommand{\dlv}{\sysfont{dlv}}
\newcommand{\ezcsp}{\sysfont{ezcsp}}
\newcommand{\ezsmt}{\sysfont{ezsmt}}
\newcommand{\embasp}{\sysfont{embasp}}
\newcommand{\fastdownward}{\sysfont{fastdownward}}
\newcommand{\ftolp}{\sysfont{f2lp}}
\newcommand{\gasp}{\sysfont{gasp}}
\newcommand{\gfd}{\sysfont{g12fd}}
\newcommand{\gecode}{\sysfont{gecode}}
\newcommand{\gidl}{\sysfont{gidl}}
\newcommand{\gnt}{\sysfont{gnt}}
\newcommand{\gringo}{\sysfont{gringo}}
\newcommand{\harvey}{\sysfont{harvey}}
\newcommand{\iclingo}{\sysfont{iclingo}}
\newcommand{\idp}{\sysfont{idp}}
\newcommand{\inca}{\sysfont{inca}}
\newcommand{\jdlv}{\sysfont{jdlv}}
\newcommand{\lctocasp}{\sysfont{lc2casp}}
\newcommand{\lparse}{\sysfont{lparse}}
\newcommand{\lpsolve}{\sysfont{lpsolve}}
\newcommand{\lptodiff}{\sysfont{lp2diff}}
\newcommand{\lptosat}{\sysfont{lp2sat}}
\newcommand{\mchaff}{\sysfont{mchaff}}
\newcommand{\measp}{\sysfont{measp}}
\newcommand{\metasp}{\sysfont{metasp}}
\newcommand{\mingo}{\sysfont{mingo}}
\newcommand{\minisat}{\sysfont{minisat}}
\newcommand{\minisatid}{\sysfont{minisatid}}
\newcommand{\minizinc}{\sysfont{minizinc}}
\newcommand{\mznfzn}{\sysfont{mzn2fzn}}
\newcommand{\nomorepp}{\sysfont{nomore++}}
\newcommand{\oclingo}{\sysfont{oclingo}}
\newcommand{\omiga}{\sysfont{omiga}}
\newcommand{\piclasp}{\sysfont{piclasp}}
\newcommand{\picosat}{\sysfont{picosat}}
\newcommand{\picat}{\sysfont{picat}}
\newcommand{\picatsat}{\sysfont{picatsat}}
\newcommand{\plasp}{\sysfont{plasp}}
\newcommand{\quontroller}{\sysfont{quontroller}}
\newcommand{\reify}{\sysfont{reify}}
\newcommand{\rosoclingo}{\sysfont{rosoclingo}}
\newcommand{\sag}{\sysfont{sag}}
\newcommand{\satz}{\sysfont{satz}}
\newcommand{\siege}{\sysfont{siege}}
\newcommand{\smac}{\sysfont{smac}}
\newcommand{\smodelscc}{\sysfont{smodels$_{\!cc}$}}
\newcommand{\smodelsr}{\sysfont{smodels}$_r$}
\newcommand{\smodels}{\sysfont{smodels}}
\newcommand{\sugar}{\sysfont{sugar}}
\newcommand{\teaspoon}{\sysfont{teaspoon}}
\newcommand{\tel}{\sysfont{tel}}
\newcommand{\telingo}{\sysfont{telingo}}
\newcommand{\unclasp}{\sysfont{unclasp}}
\newcommand{\wasp}{\sysfont{wasp}}
\newcommand{\xorro}{\sysfont{xorro}}
\newcommand{\zchaff}{\sysfont{zchaff}}
\newcommand{\zzz}{\sysfont{z3}}
\newcommand{\cryptominisat}{\sysfont{crypto-minisat}}

\newcommand{\clingoM}[1]{\clingo{\small\textnormal{[}\textsc{#1}\textnormal{]}}}
\newcommand{\ASPm}[1]{ASP\raisebox{.7pt}{[\textsc{#1}]}}

\newcommand{\flatzinc}{\sysfont{FlatZinc}}
\newcommand{\aspif}{\sysfont{aspif}}

\newcommand{\python}{Python}
\newcommand{\lua}{Lua}
\newcommand{\cpp}{C++}
\newcommand{\C}{C}
\newcommand{\java}{Java}
\newcommand{\haskell}{Haskell}

\newcommand{\el}[1]{\vspace{#1\baselineskip}}

% Some notational macros

\newcommand{\rg}[3]{{#1}{#2}\,\ldots{#2}\,{#3}}
\newcommand{\xor}{\oplus}
\newcommand{\true}{\top}
\newcommand{\false}{\bot}
\newcommand{\naf}{\mathit{not}\,}
\newcommand{\set}[1]{\{#1\}}

% Tomi's specialties (not needed in the end)

\newcommand{\TODO}[1]{%
	\vspace{1\baselineskip}\noindent\hrulefill\hspace{1em}{#1}%
	\hspace{1em}\hrulefill\vspace{1\baselineskip}}

\newcommand{\DONE}{%
	\vspace{1\baselineskip}\noindent\hrule\vspace{1\baselineskip}}

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.

\title{An Approximate Model Counter for ASP}

% Single author syntax
\iffalse % (remove the multiple-author syntax below and \iffalse ... \fi here)
\author{%
    Author name
    \affiliations
    Affiliation
    \emails
    email@example.com    % email
}
\fi
% Multiple author syntax
\author{%
Flavio Everardo$^1$\and
Markus Hecher$^2$\and
Ankit Shukla$^{3}$
\affiliations
$^1$ University of Potsdam, Germany\\
$^2$ TU Wien, Vienna, Austria\\
$^3$ JKU, Linz, Austria\\
\emails
flavio.everardo@cs.uni-potsdam.de,
mhecher@gmail.com,
ankit.shukla@jku.at
}

\begin{document}

\maketitle

\begin{abstract}
(\asp) XXX
\end{abstract}

\section{Introduction} \label{sec:introduction}

Parity (\XOR{}) constraints have been recently accommodated in Answer Set Programming (ASP;~\cite{liftschitz99a/})
as the fundamental part of the system \xorro{}~\cite{DBLP:conf/lpnmr/EverardoJKS19}.
% 
With different solving approaches over parity constraints in \xorro{}, these constraints amount to the classical \XOR{} operator following the aggregates-like syntax by means of theory atoms.
They are interpreted as directives, solved on top of an ASP program acting as answer sets filters that do not satisfy the parity constraint in question.
%
Currently, these parity constraints may not occur in the bodies nor the heads of rules.
However, they fit perfectly for reasoning modes like sampling (near-uniform generation)
or (approximate) model counting~\cite{gosase07a,gohosase07b,chmeva13a,chmeva13b,soomee19a}
where their purpose is to partition the search space.


%Parity constraints constitute the foundations of reasoning modes like sampling or (approximate) model counting \cite{DBLP:journals/corr/abs-1806-02239}, as well as circuit verification and cryptography \cite{DBLP:conf/laitinen2014extending}.
%
With most of their applications in the neighboring area of Satisfiability Testing (SAT) \cite{DBLP:journals/corr/abs-1806-02239},
few attention has been paid to the parity constraints treatment as well as reasoning modes like sampling or model counting into ASP.%~\cite{kalepesc16a}.
%
To this end, we present an extension to \xorro{} towards counting answer sets following the work from~\cite{DBLP:conf/cp/ChakrabortyMV13}
benefiting from the advanced interfaces of \clingo{},
and the sophisticated solving techniques developed in SAT~(e.g. the award-winning solver \cryptominisat~\cite{DBLP:conf/sat/SoosNC09}).
%
This paper is structured in ...

\section{Parity Constraints and Search Space Partition with  \emph{xorro}} \label{sec:xorro}

Towards the definition of parity aggregates, let $\true$ and $\false$
stand for the Boolean constants \emph{true} and \emph{false},
respectively, and a literal is an atom $a$ and its negation $\neg a$.
\footnote{In the context of ASP, we understand the negation $\neg$ as the default negation.}
%
Given atoms $a_1$ and $a_2$, the \emph{exclusive or}
(\XOR{} for short) of $a_1$ and $a_2$ is denoted by $a_1\xor a_2$ and
it is satisfied if \emph{either} $a_1$ \emph{or} $a_2$ is true (but
not both).
Generalizing the idea for $n$ distinct atoms
$\rg{a_1}{,}{a_n}$, we obtain an $n$-ary \XOR{} constraint
$\rg{(((a_1\xor a_2}{)}{\xor\,a_n)}$ by multiple applications of
$\xor$. Since it is satisfied iff an odd number of atoms among
$\rg{a_1}{,}{a_n}$ are true,
we can simply refer it to as an \emph{odd parity constraint}
and it can be written simply as
$\rg{a_1}{\xor}{a_n}$ due to associativity.
%
Analogously, an \emph{even parity} (or \XOR{}) \emph{constraint} is defined by
$\rg{a_1}{\xor}{a_n}\xor\true$ as it is satisfied iff an even number
of atoms among $\rg{a_1}{,}{a_n}$ hold. Then, e.g.,
%
$a_1\xor a_2\xor\true$
%
is satisfied iff none or both of $a_1$ and $a_2$ hold.
%
Similarly, an \emph{even parity constraint} can be represented in terms of the \emph{odd} parity by an uneven
number of negated literals. 
For instance, $\neg a_1\xor a_2$ is equivalent to $a_1\xor a_2\xor\true$ and pairs of negated literals cancel parity inversion, for example $\neg a_1\xor \neg a_2$ is equivalent to $a_1\xor a_2$
%Following~\cite{hanjia12a,laitinen14a} a \emph{parity constraint} is in a \emph{normal(or standard)-form} if all of its literals
%are positive and (pairs of) duplicates are removed.
%For example, the parity constraint $a_1\xor a_2\xor \neg a_3\xor a_2$ equals to $a_1\xor a_3\xor\true$.
Finally, \XOR{} constraints of forms $a\xor\false$ and $a\xor\true$
are called \emph{unary}.

To accommodate parity constraints in ASP's input language,
we rely on \clingo’s theory language extension~\cite{DBLP:conf/iclp/GebserKKOSW16}
following the common syntax of \emph{aggregates}~\cite{DBLP:journals/tplp/GebserHKLS15}:

\begin{verbatim}
&even{1:p(1);4: not p(4);5:p(5)}.
&odd{2:not p(2);5: not p(5);6:p(6)}.
&odd{X:p(X), X > 2}.
&even{X:p(X), X < 3}.
&odd{5:p(5)}.
\end{verbatim}

%
That is, \xorro{} extends the input language of \clingo{} by
aggregate names \texttt{\&even} and \texttt{\&odd} that are followed
by a set, whose elements are \emph{terms} conditioned by
conjunctions of literals separated by commas.%
%
\footnote{In turn, multiple conditional terms within an aggregate are
	separated by semicolons.}
%
From a search space of 64 answer sets in the context of the choice rule \texttt{\set{p(1..6)}.}, the parity constraints shown above
amounts to the \XOR{} operations:
$p(1) \xor p(4) \xor p(5)$, $p(2) \xor p(5) \xor p(6)$, $p(3) \xor p(4) \xor p(5) \xor p(6)$, $p(1) \xor p(2) \xor \top$, and $p(1) \xor \bot$
%(where $\bot$ and $\top$ stand for the Boolean constants true and false, respectively)
yield the answer sets~\texttt{\set{p(5)}} and \texttt{\set{p(1),p(2),p(4),p(5),p(6)}}.
This means that each parity constraint divides the search space (roughly) by half, and for this symmetric search space example with five parity constraints ($m=5$), 
we have $2^m$ clusters, each with two answer sets.


%The semantics of aggregates formed with keywords \texttt{\&even} and
%\texttt{\&odd} is defined by \emph{even} and \emph{odd} parity constraints,
%respectively.
%In this implementation,
Currently, these constraints are interpreted as directives,
filtering answer sets that do not satisfy the parity constraint in question.
\footnote{Cannot occur either in the bodies or heads of rules.}
%
Hence, the first two 
constraints hold for any combination of an uneven number of literals from \texttt{p(1), p(4), p(5)} and \texttt{p(2), p(5), p(6)} respectively.
The third constraint holds if an odd number of literals from \texttt{p(3)} to \texttt{p(6)} are true, while the fourth constraint requires that either none or both of
the atoms \texttt{p(1)} and \texttt{p(2)} are included.
The last parity constraint discards any answer set not containing the atom \texttt{p(5)}.

\xorro{} handles parity constraints in six different ways as shown in Table~\ref{table:xorro_approaches}, 
where the first three corresponds to ASP encodings of parity constraints (eager approaches), and the last three to theory propagators within \clingo{}'s Python interface (lazy approaches).~\footnote{The distinction of eager and lazy approaches follows the methodology in Satisfiability modulo theories~\cite{baseseti09a}.}




\begin{table*}[t]
	% 	\centering
	\caption{\xorro{} approaches to handle parity constraints}\label{table:xorro_approaches}
	%\vspace{-5mm}
	\begin{tabular}{ l|l }
		Approach  & Description  \\
		\hline\hline
		count     & Add count aggregates with a modulo 2 operation  \\  
		list,tree & Translate binary \XOR{} operators into rules forming list and tree structures \\
		%            & (binary operators are arranged in list/tree)\\
		countp    & Propagator simply counting truth literals on total assignments\\
		up        & Propagator implementing unit propagation\\
		gje       & Propagator implementing (non-incremental) Gauss-Jordan Elimination
		
	\end{tabular}
	%	\vspace{-7mm}
\end{table*}
%
%Finally, we empirically evaluate the different approaches in view of their impact on solving performance,
%while varying the number and size of parity constraints compared against \clingo{} solving time.
%
%The experiments show that \xorro{} scales depending on the combination of the number, density, and preprocessing of the parity constraints.
%
%When increasing the number of high-density constraints as used in sampling (\XOR{}s with a size of half the program variables), we start to see that the solving time increases concerning \clingo.
%
%Comparing to previous approaches, the eager counting, and the list (from the previous \xorro{} and \emph{harvey}), both stay behind for sampling purposes. Their scalability is subjected to the density of the parity constraints and preprocessing, and particularly, grounding becomes the bottleneck for the counting approach with aggregates.

\section{Hashing and Xor's} \label{sec:hashing}
Apriori we do not know the distribution of the solution set; $Sol(\phi)$. 
%
How to perform a good hashing if we have no knowledge of the distribution of solutions? i.e., how to partition the $Sol(\phi)$ into cells with a roughly equal number of solutions?
%
\textbf{Universal hashing}~\cite{DBLP:conf/stoc/CarterW77} comes to our rescue. 
%
%To partition the $Sol(\phi)$ into roughly equal small cells without knowing the distribution of the solution we use universal hashing. 
The idea is: pick a function randomly from a family of hash functions.  By choosing a random hash function from a family, we randomize over arbitrary input distribution. This guarantees a low number of collisions in expectation irrespective of how data is chosen.
%

\begin{definition}
A family of functions $\mathcal{H}=\{h: U \to [m]\}$  is called a universal family if, 
\[ \forall x,y\in U,~x\neq y:~~\Pr _{h\in H}[h(x)=h(y)]\leq {\frac {1}{m}} \]	
\end{definition}

For model counting with high guarantees this is not enough, we not only need every input to be hash uniformly but also hashed independently. We need a family of $k$-wise independent hash functions~\cite{DBLP:conf/focs/WegmanC79},
%
%$H(n, m, k)$: 
%Need Family of $k$-wise independent hash functions mapping $\{0, 1\}^{U}$
% $\to$ $\{0, 1\}^{m}$ such that every $k$ elements are mapped independently.
formally, 
a family $\mathcal{H} = {h : U \to [m]}$ of hash functions
is $k$-wise independent if:
\begin{enumerate}
	\item For any distinct keys $x_1, ..., x_k \in U$, the hash codes
	$h(x_1), ..., h(x_k)$ are independent random variables.
	\item For any fixed $x$, $h(x)$ is uniformly distributed in [m].
\end{enumerate}

Technical definition generally used for the $k$-wise independent:
% i.e.,  A random hash function $h$ is $k$-independent iffor all choices of distinct $x_1$,…,$x_k$ the values $h(x_1)$,…,$h(x_k)$ are independent.
\begin{definition}
	Let $\mathcal{H}=\{h: U \to [m]\}$ be a family of hash functions. For any distinct $x_1$, . . . , $x_k \in U$ and any $y_1$, ..., $y_k \in [m]$ we have the following guarantee.
	
	$~~\Pr_{h\in H}
	[h(x_1) = y_1 \land ... \land h(x_k) = y_k] = \frac {1}
	{m^
		k}$
\end{definition}

Higher the $k$, stronger will be the guarantee on a range of the size of cells. To encode $k$-wise independence we will require polynomial of degree $k$ - $1$. But higher the $k$, harder it will be to solve the formula with these constraints. Due to this trade-off we just use 3-wise independent. If we use $k$-wise independence, all cells will be  small and we will get a \textbf{uniform generation}. With $3$-wise independence we achieve: \emph{a random cell is small with high probabablity}, also called \textbf{almost-uniform generation}.


The canonical construction of a $k$-wise independent family is based on polynomials
of degree $k$ - $1$. Let $p \geq |U|$ be prime. Picking random $a_0,...,a_{k - 1} \in \{0, . . . , p$-$ 1\}$,
the hash function is defined by:
\[ h(x) = ( ( a_{k-1} x^ {k - 1} + ... + a_1 x + a_0) \,\, mod \,\, p) \,\, mod \,\,  m\]


For $p \gg	 m$, the hash function is statistically close to $k$-wise independent.

The 2-wise independent hash is: 

\[ h(x) = (((a_1 x + a_0) \,\, mod \,\, p) \,\, mod \,\, m ) \]

\section{ApproxASP} \label{approxasp}
\textbf{ApproxMC Algorithm into ASP}

\begin{algorithm}[h]
	\textbf{ApproxASP}($F$, $\epsilon$, $\delta$) \;
	\SetAlgoLined
	\KwResult{Approximate number of answer sets}
	$counter \gets 0$ ; $C \gets emptyList$\;
	$pivot \gets  2 \, \times $ \textbf{ComputeThreshold($\epsilon$)} \;
	$S \gets Xampler(F, pivot + 1)$ // {Solve pivot+1 AS}  \;
	\eIf{ $|S| \leq pivot$}
	{ % Open If
		\textbf{return} $|S|$ 
	} % Close If
	{ % Open Else
		$t \gets $ \textbf{ComputeIterCount($\delta$)} 
		
		\While{$counter < t$}{
			$c \gets $ \textbf{ApproxASPCore($F, pivot$)} \;
			$counter \gets counter + 1$ \;
			\If{$c \neq \bot$}{\textbf{AddToList($C,c$)}}
		} % Close While
	} % Close else
	$finalCount \gets $ \textbf{FindMedian($C$)} \;
	\textbf{return} $finalCount$
	
	\caption{ApproxMC into ASP}
\end{algorithm}


\begin{algorithm}
	\textbf{return} $\lceil 3 e^{1/2} (1 + \frac{1}{\epsilon})^2 \rceil$
	\caption{ComputeThreshold($\epsilon$)}
\end{algorithm}

\begin{algorithm}
	\textbf{return} $\lceil 35 \log_2 (3/\delta) \rceil$
	\caption{ComputeIterCount($\delta$)}
\end{algorithm}

\begin{algorithm}
	/* Assume $z_1 , ..., z_n $ are the varaibles of $F$ */ \\
	$ l \gets \lfloor \log_2 (pivot) - 1 \rfloor$ \\
	$ i \gets l - 1$ \\
	
	\While{($1 \leq |S| \leq pivot $) or ($i = n$)}{
		$ i \gets i + 1$ \\
		Choose $h$ at random from $H_{xor}(n, i - l, 3)$ \\
		Choose $\alpha$ at random from $\{0,1\}^{i-l}$ \\
		$S \gets Xampler(F \land (h(z_1, ..., z_n)=\alpha, pivot + 1)$ %\Comment*[r]{Solve $P \land XOR$}  
	}
	
	\eIf{ $|S|$ $> pivot$ or $|S|$ = 0}
	{\textbf{return} $\bot$}
	{\textbf{return} $|S|$ $\cdot 2^{i-l}$}
	
	
	
	\caption{ApproxASPCore($F, pivot$)}
\end{algorithm}


\section{Experiments} \label{sec:experiments}
In progress...


\section{Conclusion} \label{sec:conclusion}
XXX

%% The file kr.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{kr}
\bibliography{NMR2020}

\end{document}

