%%%% kr-instructions.tex -- version 1.2 (27-Feb-2020)

\typeout{KR2020 Instructions for Authors}

% These are the instructions for authors for KR-20.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
%\usepackage{algorithm}
%\usepackage{algorithmic}
\urlstyle{same}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}

% added by Ankit
\usepackage{xspace}
\def\approxmc{\textsf{ApproxMC}\xspace}
\def\approxasc{\textsf{ApproxASC}\xspace}
\def\asp{\textsf{\#ASP}\xspace}
\newtheorem{definition}{Definition}

% Copied from Flavio draft
\usepackage{url}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{float}
\usepackage{listings}

%\usepackage[ruled,vlined]{algorithm2e}
%\SetKwComment{Comment}{$\triangleright$\ }{}

\newcommand{\XOR}{\textsc{xor}} % just an idea


% - systems ----------------------------------------------------------------------
% >>> NOT USED in BOOK <<<
\newcommand{\sysfont}{\textit}
\newcommand{\acthex}{\sysfont{acthex}}
\newcommand{\adsolver}{\sysfont{adsolver}}
\newcommand{\anthem}{\sysfont{anthem}}
\newcommand{\asparagus}{\sysfont{asparagus}}
\newcommand{\aspartame}{\sysfont{aspartame}}
\newcommand{\aspic}{\sysfont{aspic}}
\newcommand{\aspcud}{\sysfont{aspcud}}
\newcommand{\aspmt}{\sysfont{aspmt}}
\newcommand{\asprilo}{\sysfont{asprilo}}
\newcommand{\asprin}{\sysfont{asprin}}
\newcommand{\assat}{\sysfont{assat}}
\newcommand{\berkmin}{\sysfont{berkmin}}
\newcommand{\chuffed}{\sysfont{chuffed}}
\newcommand{\chasp}{\sysfont{chasp}}
\newcommand{\claspD}{\sysfont{claspD}}
\newcommand{\claspar}{\sysfont{claspar}}
\newcommand{\claspfolio}{\sysfont{claspfolio}}
\newcommand{\clasp}{\sysfont{clasp}}
\newcommand{\claspre}{\sysfont{claspre}}
\newcommand{\clingcon}{\sysfont{clingcon}}
\newcommand{\clingo}{\sysfont{clingo}}
\newcommand{\clingod}[1]{\clingo\textnormal{[}\textsc{#1}\textnormal{]}}
\newcommand{\cmodels}{\sysfont{cmodels}}
\newcommand{\coala}{\sysfont{coala}}
\newcommand{\cplex}{\sysfont{cplex}}
\newcommand{\dingo}{\sysfont{dingo}}
\newcommand{\dflat}{\sysfont{dflat}}
\newcommand{\dlvhex}{\sysfont{dlvhex}}
\newcommand{\dlv}{\sysfont{dlv}}
\newcommand{\ezcsp}{\sysfont{ezcsp}}
\newcommand{\ezsmt}{\sysfont{ezsmt}}
\newcommand{\embasp}{\sysfont{embasp}}
\newcommand{\fastdownward}{\sysfont{fastdownward}}
\newcommand{\ftolp}{\sysfont{f2lp}}
\newcommand{\gasp}{\sysfont{gasp}}
\newcommand{\gfd}{\sysfont{g12fd}}
\newcommand{\gecode}{\sysfont{gecode}}
\newcommand{\gidl}{\sysfont{gidl}}
\newcommand{\gnt}{\sysfont{gnt}}
\newcommand{\gringo}{\sysfont{gringo}}
\newcommand{\harvey}{\sysfont{harvey}}
\newcommand{\iclingo}{\sysfont{iclingo}}
\newcommand{\idp}{\sysfont{idp}}
\newcommand{\inca}{\sysfont{inca}}
\newcommand{\jdlv}{\sysfont{jdlv}}
\newcommand{\lctocasp}{\sysfont{lc2casp}}
\newcommand{\lparse}{\sysfont{lparse}}
\newcommand{\lpsolve}{\sysfont{lpsolve}}
\newcommand{\lptodiff}{\sysfont{lp2diff}}
\newcommand{\lptosat}{\sysfont{lp2sat}}
\newcommand{\mchaff}{\sysfont{mchaff}}
\newcommand{\measp}{\sysfont{measp}}
\newcommand{\metasp}{\sysfont{metasp}}
\newcommand{\mingo}{\sysfont{mingo}}
\newcommand{\minisat}{\sysfont{minisat}}
\newcommand{\minisatid}{\sysfont{minisatid}}
\newcommand{\minizinc}{\sysfont{minizinc}}
\newcommand{\mznfzn}{\sysfont{mzn2fzn}}
\newcommand{\nomorepp}{\sysfont{nomore++}}
\newcommand{\oclingo}{\sysfont{oclingo}}
\newcommand{\omiga}{\sysfont{omiga}}
\newcommand{\piclasp}{\sysfont{piclasp}}
\newcommand{\picosat}{\sysfont{picosat}}
\newcommand{\picat}{\sysfont{picat}}
\newcommand{\picatsat}{\sysfont{picatsat}}
\newcommand{\plasp}{\sysfont{plasp}}
\newcommand{\quontroller}{\sysfont{quontroller}}
\newcommand{\reify}{\sysfont{reify}}
\newcommand{\rosoclingo}{\sysfont{rosoclingo}}
\newcommand{\sag}{\sysfont{sag}}
\newcommand{\satz}{\sysfont{satz}}
\newcommand{\siege}{\sysfont{siege}}
\newcommand{\smac}{\sysfont{smac}}
\newcommand{\smodelscc}{\sysfont{smodels$_{\!cc}$}}
\newcommand{\smodelsr}{\sysfont{smodels}$_r$}
\newcommand{\smodels}{\sysfont{smodels}}
\newcommand{\sugar}{\sysfont{sugar}}
\newcommand{\teaspoon}{\sysfont{teaspoon}}
\newcommand{\tel}{\sysfont{tel}}
\newcommand{\telingo}{\sysfont{telingo}}
\newcommand{\unclasp}{\sysfont{unclasp}}
\newcommand{\wasp}{\sysfont{wasp}}
\newcommand{\xorro}{\sysfont{xorro}}
\newcommand{\zchaff}{\sysfont{zchaff}}
\newcommand{\zzz}{\sysfont{z3}}
\newcommand{\cryptominisat}{\sysfont{crypto-minisat}}

\newcommand{\clingoM}[1]{\clingo{\small\textnormal{[}\textsc{#1}\textnormal{]}}}
\newcommand{\ASPm}[1]{ASP\raisebox{.7pt}{[\textsc{#1}]}}

\newcommand{\flatzinc}{\sysfont{FlatZinc}}
\newcommand{\aspif}{\sysfont{aspif}}

\newcommand{\python}{Python}
\newcommand{\lua}{Lua}
\newcommand{\cpp}{C++}
\newcommand{\C}{C}
\newcommand{\java}{Java}
\newcommand{\haskell}{Haskell}

\newcommand{\el}[1]{\vspace{#1\baselineskip}}

% Some notational macros

\newcommand{\rg}[3]{{#1}{#2}\,\ldots{#2}\,{#3}}
\newcommand{\xor}{\oplus}
\newcommand{\true}{\top}
\newcommand{\false}{\bot}
\newcommand{\naf}{\mathit{not}\,}
\newcommand{\set}[1]{\{#1\}}

% Tomi's specialties (not needed in the end)

\newcommand{\TODO}[1]{%
	\vspace{1\baselineskip}\noindent\hrulefill\hspace{1em}{#1}%
	\hspace{1em}\hrulefill\vspace{1\baselineskip}}

\newcommand{\DONE}{%
	\vspace{1\baselineskip}\noindent\hrule\vspace{1\baselineskip}}

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.

\title{An Approximate Model Counter for ASP}

% Single author syntax
\iffalse % (remove the multiple-author syntax below and \iffalse ... \fi here)
\author{%
    Author name
    \affiliations
    Affiliation
    \emails
    email@example.com    % email
}
\fi
% Multiple author syntax
\author{%
Flavio Everardo$^1$\and
Markus Hecher$^2$\and
Ankit Shukla$^{3}$
\affiliations
$^1$ University of Potsdam, Germany\\
$^2$ TU Wien, Vienna, Austria\\
$^3$ JKU, Linz, Austria\\
\emails
flavio.everardo@cs.uni-potsdam.de,
mhecher@gmail.com,
ankit.shukla@jku.at
}

\begin{document}

\maketitle

\begin{abstract}
%Answer Set Programming (ASP) is a declarative framework that is well-suited for problems in KR, AI and other areas as well as plenty of practical applications.
%While modern ASP solvers not only compute one solution (answer set), but actually support different reasoning modes, the problem of counting answer sets has not been subject to intense studies yet.
Answer Set Programming (ASP) is a declarative framework that is well-suited for problems in KR, AI, and other areas with plenty of practical applications.
While modern ASP solvers not only compute one solution (answer set) but support different reasoning modes, the problem of counting answer sets has not been subject to intense studies.
This is in contrast to propositional satisfiability (SAT), where several applications and problems related to quantitative reasoning trace back to model counting. However, due to high computational complexity and depending on the actual application, approximate counting might be sufficient. Indeed, there are plenty of applications, where approximate counting for SAT is well-suited. This work deals with establishing approximate model counting for ASP, thereby lifting ideas from SAT to ASP. We present the first approximate counter for ASP and also show preliminary experiments for several problems.
\end{abstract}

\section{Introduction} \label{sec:introduction}
%
Answer Set Programming (ASP)~\cite{Lifschitz99,BrewkaEiterTruszczynski11,GebserKaminskiKaufmannSchaub12} is a 
problem modeling and solving framework that is well-known in the area 
of knowledge representation and reasoning and artificial intelligence. 
%
This framework has been practically applied for several 
problems~\cite{BalducciniGelfondNogueira06a,NiemelaSimonsSoininen99,NogueiraBalducciniGelfond01a,GuziolowskiEtAl13a,SchaubWoltran18}.
%

Recently, there has been growing interest for counting solutions of problems.
%
Indeed, counting solutions is a well-known task not only in mathematics and computer
science, but also in other
areas~\cite{ChakrabortyMeelVardi16a,DomshlakHoffmann07a,GomesKautzSabharwalSelman08a,SangBeameKautz05a}.
%
%
%
Examples cover also applications in machine learning and probabilistic inference~\cite{ChaviraDarwiche08a}.
%
%
In terms of computational complexity, counting has been well-studied since the
late
70s~\cite{DurandHermannKolaitis05,HemaspaandraVollmer95a,Valiant79,Valiant79b}.
%
There are also results for counting involving projection, where one wants to
count only with respect to a given set of projection atoms,
which has been established for logic~\cite{AzizChuMuise15a,CapelliMengel19,FichteEtAl18,LagniezMarquis19a,GuptaSharmaRoy19a,SharmaRoySoos19a},
reliability estimation~\cite{MeelEtAl17a} as well as
answer set programming~\cite{GebserKaufmannSchaub09a,Aziz15a,FichteHecher19}.
%

Given that in general counting answer sets is rather hard, namely ${\#\cdot\text{coNP}}$-complete~\cite{FichteEtAl17,DurandHermannKolaitis05}, which further increases
to ${\#\cdot\Sigma_2^P}$-completeness~\cite{FichteHecher19} if counting with respect to a projection,
a different approach than exact counting seems to be required in practice.
%
Indeed, such approaches were successful for propositional logic (SAT), where reasoning modes like sampling (near-uniform generation)
or (approximate) model counting~\cite{gosase07a,gohosase07b,chmeva13a,chmeva13b,soomee19a}
were studied.
%
For this purpose, so-called parity constraints  (\XOR{} constraints) are used specifically to partition the search space in parts that preferably are of roughly the same size.

Parity constraints have been recently accommodated in ASP
as the fundamental part of the system \xorro{}~\cite{DBLP:conf/lpnmr/EverardoJKS19}.
% 
With different solving approaches over parity constraints in \xorro{}, these constraints amount to the classical \XOR{} operator following the aggregates-like syntax by means of theory atoms.
They are interpreted as directives, solved on top of an ASP program acting as answer set filters that do not satisfy the parity constraint in question.
%
%Currently, these parity constraints may not occur in the bodies nor the heads of rules.



%Parity constraints constitute the foundations of reasoning modes like sampling or (approximate) model counting \cite{DBLP:journals/corr/abs-1806-02239}, as well as circuit verification and cryptography \cite{DBLP:conf/laitinen2014extending}.
%
With most of the applications of \XOR{} constraints in the neighboring area of SAT~\cite{DBLP:journals/corr/abs-1806-02239},
only few attention has been paid to treat parity constraints as well as reasoning modes like sampling or approximate model counting for ASP. %~\cite{kalepesc16a}.
%
To this end, we present an extension to \xorro{} towards approximate answer set counting following the work from~\cite{DBLP:conf/cp/ChakrabortyMV13}
benefiting from the advanced interfaces of \clingo{},
and the sophisticated solving techniques developed in SAT~(e.g. the award-winning solver \cryptominisat~\cite{DBLP:conf/sat/SoosNC09}).
%
%This paper is structured in ...

\section{Preliminaries}

\smallskip
\noindent\textbf{Answer Set Programming (ASP).} %
% ASP is a declarative modeling and problem solving framework that
% combines techniques of knowledge representation and database
% theory. Two of the main advantages of ASP are its
% expressiveness~\cite{BrewkaEiterTruszczynski11} and, when using
% non-ground programs, its advanced declarative problem modelling
% capability. Prior to solving, non-ground programs are usually compiled
% into ground ones by a grounder.  For particular non-ground programs,
% treewidth guarantees are known~\cite{BliemEtAl17a}.
% In this paper, we restrict ourselves to ground ASP programs.  For a
% comprehensive introduction, we refer to introductory
% literature~\cite{BrewkaEiterTruszczynski11,JanhunenNiemela16a}.
%
%We assume familiarity with propositional satisfiability (\SAT)~\cite{BiereHeuleMaarenWalsh09,KleineBuningLettman99}
We follow standard definitions of propositional ASP~\cite{BrewkaEiterTruszczynski11}.
%For comprehensive foundations, we refer to introductory
%literature~\cite{BrewkaEiterTruszczynski11,JanhunenNiemela16a}.
%
Let $m$, $n$, $\ell$ be non-negative integers such that
$m \leq n \leq \ell$, $a_1$, $\ldots$, $a_\ell$ be distinct propositional
atoms. Moreover, we refer by \emph{literal} to an atom or the negation
thereof.
%, and
%$l \in \{a_1, \neg a_1\}$ being a \emph{literal},~i.e., an atom or the negation thereof.
%
A \emph{(logic) program}~$\Pi$ is a set of \emph{rules} of the form
%
%\begin{align*}
%\smallskip
%\hfill
%\vspace{-0.75em}
\(
a_1\vee \cdots \vee a_m \leftarrow a_{m+1}, \ldots, a_{n}, \neg
a_{n+1}, \ldots, \neg a_\ell.
%
\)
%\hfill
%\smallskip
%
%\end{align*}
%
%
% \noindent Intuitively this requires at least one atom of
% $a_1, \ldots, a_\ell$ to be true if all atoms
% $a_{\ell+1}, \ldots, a_m$ are true and there is no evidence that any
% atoms of $a_{m+1}, \ldots, a_n$ are true. The set of
% \emph{well-defined programs} among atoms~$X$ is given by~$prog(X)$.
%
%
%
%Let $\at(\Pi) \eqdef \SB
%\at(r) \SM r \in \Pi \SE$ be the atoms occuring in a program~$\Pi$,
%
%Therefore, let $\choice(\Pi), \disj(\Pi),
%\opt(\Pi)$ and $\weight(\Pi)$ denote the set of all choice, disjunctive,
%optimization and weight rules in a program~$\Pi$, respectively.
%
%
%\noindent 
For a rule~$r$, we let $H_r = \{a_1, \ldots, a_m\}$,
$B^+_r = \{a_{m+1}, \ldots, a_{n}\}$, and
$B^-_r = \{a_{n+1}, \ldots, a_\ell\}$.
%
% We call $H_r$ the \emph{head}, $B^+_r$ the \emph{positive body}, and
% $B^-(r)$ the \emph{negative body} of~$r$.
%
% , and $B_r \eqdef B^+_r \cup \SB \neg b \SM b \in B^-_r \SE$ the
% \emph{body} of~$r$.\nb{Do we really need the body?}
%
We denote the sets of \emph{atoms} occurring in a rule~$r$ or in a
program~$\Pi$ by $\text{at}(r) = H_r \cup B^+_r \cup B^-_r$ and
$\text{at}(\Pi)= \bigcup_{r\in\Pi} \text{at}(r)$.
%
%For a set~$X\subseteq\at(\Pi)$ of atoms, we let~$\overline{X}\eqdef \{\neg x\mid x\in X\}$.
%
%Let $\Pi$ be a program.
%
%A program~$\Pi'$ is a \emph{sub-program of~$\Pi$} if~$\Pi'\subseteq\Pi$.
%A program~$\Pi'$ is a \emph{sub-program of~$\Pi$}, if symbols
%$\Pi' \subseteq \Pi$, if for each rule~$r' \in P'$ there is
%%exactly one
%a rule~$r \in \Pi$ with $H_{r'} \subseteq H_r$,
%$B^+_{r'} \subseteq B^+_r$, and $B^-_{r'} \subseteq B^-_r$. \nb{why so complicated sub-programs?}
%
%Program~$\Pi$ is \emph{normal}, if $\Card{H_r} \leq 1$ for
%every~$r \in \Pi$.
%
%The \emph{positive dependency digraph}~$D_\Pi$ of $\Pi$ is the
%directed graph defined on the set~$\bigcup_{r\in \Pi}H_r \cup B^+_r$ of atoms, where there is a directed edge from vertex~$a$ to~$b$ iff there is a rule~$r \in \Pi$ with $a\in B^+_r$ and~$b\in H_r$.
%
%
% The class~\HCF contains all head-cycle-free programs.\nb{do we need
% the class?}

An \emph{interpretation} $I$ is a set of atoms. $I$ \emph{satisfies} a
rule~$r$ if $(H_r\,\cup\, B^-_r) \,\cap\, I \neq \emptyset$ or
$B^+_r \setminus I \neq \emptyset$.  $I$ is a \emph{model} of $\Pi$
if it satisfies all rules of~$\Pi$, in symbols $I \models \Pi$. %, if $I$ satisfies every rule~$r \in \Pi$.
%
%For brevity, we view propositional formulas 
%as sets of clauses that need to be satisfied, and
%use the notion of interpretations, models, and satisfiability analogously. %and 
%satisfiability 
%also in the context of satisfiability of
%propositional formulas.
%\nb{only used once}
%
The \emph{Gelfond-Lifschitz
  (GL) reduct} of~$\Pi$ under~$I$ is the program~$\Pi^I$ obtained
from $\Pi$ by first removing all rules~$r$ with
$B^-_r\cap I\neq \emptyset$ and then removing all~$\neg z$ where
$z \in B^-_r$ from every remaining
rule~$r$~\cite{GelfondLifschitz91}. %
%
$I$ is an \emph{answer set} of a program~$\Pi$ if $I$ is a minimal
model of~$\Pi^I$. %
%
%Deciding whether a disjunctive program has an answer set is
%\SIGMA{2}{P}-complete~\cite{EiterGottlob95}. 
The problem of deciding whether an ASP program has an answer set is called
\emph{consistency}, which is $\Sigma_2^P$-complete~\cite{EiterGottlob95}. 
%
If no rule uses disjunction, the complexity drops to
\text{NP}-complete~\cite{BidoitFroidevaux91,MarekTruszczynski91}.

\begin{example}
\end{example}

\section{Parity Constraints and Search Space Partition with  \emph{xorro}} \label{sec:xorro}

Towards the definition of parity aggregates, let $\true$ and $\false$
stand for the Boolean constants \emph{true} and \emph{false},
respectively, and a literal is an atom $a$ and its negation $\neg a$.
\footnote{In the context of ASP, we understand the negation $\neg$ as the default negation.}
%
Given atoms $a_1$ and $a_2$, the \emph{exclusive or}
(\XOR{} for short) of $a_1$ and $a_2$ is denoted by $a_1\xor a_2$ and
it is satisfied if \emph{either} $a_1$ \emph{or} $a_2$ is true (but
not both).
Generalizing the idea for $n$ distinct atoms
$\rg{a_1}{,}{a_n}$, we obtain an $n$-ary \XOR{} constraint
$\rg{(((a_1\xor a_2}{)}{\xor\,a_n)}$ by multiple applications of
$\xor$. Since it is satisfied iff an odd number of atoms among
$\rg{a_1}{,}{a_n}$ are true,
we can simply refer it to as an \emph{odd parity constraint}
and it can be written simply as
$\rg{a_1}{\xor}{a_n}$ due to associativity.
%
Analogously, an \emph{even parity} (or \XOR{}) \emph{constraint} is defined by
$\rg{a_1}{\xor}{a_n}\xor\true$ as it is satisfied iff an even number
of atoms among $\rg{a_1}{,}{a_n}$ hold. Then, e.g.,
%
$a_1\xor a_2\xor\true$
%
is satisfied iff none or both of $a_1$ and $a_2$ hold.
%
Similarly, an \emph{even parity constraint} can be represented in terms of the \emph{odd} parity by an uneven
number of negated literals. 
For instance, $\neg a_1\xor a_2$ is equivalent to $a_1\xor a_2\xor\true$ and pairs of negated literals cancel parity inversion, for example $\neg a_1\xor \neg a_2$ is equivalent to $a_1\xor a_2$
%Following~\cite{hanjia12a,laitinen14a} a \emph{parity constraint} is in a \emph{normal(or standard)-form} if all of its literals
%are positive and (pairs of) duplicates are removed.
%For example, the parity constraint $a_1\xor a_2\xor \neg a_3\xor a_2$ equals to $a_1\xor a_3\xor\true$.
Finally, \XOR{} constraints of forms $a\xor\false$ and $a\xor\true$
are called \emph{unary}.

To accommodate parity constraints in ASP's input language,
we rely on \clingo’s theory language extension~\cite{DBLP:conf/iclp/GebserKKOSW16}
following the common syntax of \emph{aggregates}~\cite{DBLP:journals/tplp/GebserHKLS15}:

\begin{verbatim}
&even{1:p(1);4: not p(4);5:p(5)}.
&odd{2:not p(2);5: not p(5);6:p(6)}.
&odd{X:p(X), X > 2}.
&even{X:p(X), X < 3}.
&odd{5:p(5)}.
\end{verbatim}

%
That is, \xorro{} extends the input language of \clingo{} by
aggregate names \texttt{\&even} and \texttt{\&odd} that are followed
by a set, whose elements are \emph{terms} conditioned by
conjunctions of literals separated by commas.%
%
\footnote{In turn, multiple conditional terms within an aggregate are
	separated by semicolons.}
%
From a search space of 64 answer sets in the context of the choice rule \texttt{\set{p(1..6)}.}, the parity constraints shown above
amounts to the \XOR{} operations:
$p(1) \xor p(4) \xor p(5)$, $p(2) \xor p(5) \xor p(6)$, $p(3) \xor p(4) \xor p(5) \xor p(6)$, $p(1) \xor p(2) \xor \top$, and $p(1) \xor \bot$
%(where $\bot$ and $\top$ stand for the Boolean constants true and false, respectively)
yield the answer sets~\texttt{\set{p(5)}} and \texttt{\set{p(1),p(2),p(4),p(5),p(6)}}.
This means that each parity constraint divides the search space (roughly) by half, and for this symmetric search space example with five parity constraints ($m=5$), 
we have $2^m$ clusters, each with two answer sets.


%The semantics of aggregates formed with keywords \texttt{\&even} and
%\texttt{\&odd} is defined by \emph{even} and \emph{odd} parity constraints,
%respectively.
%In this implementation,
Currently, these constraints are interpreted as directives,
filtering answer sets that do not satisfy the parity constraint in question.
\footnote{Cannot occur either in the bodies or heads of rules.}
%
Hence, the first two 
constraints hold for any combination of an uneven number of literals from \texttt{p(1), p(4), p(5)} and \texttt{p(2), p(5), p(6)} respectively.
The third constraint holds if an odd number of literals from \texttt{p(3)} to \texttt{p(6)} are true, while the fourth constraint requires that either none or both of
the atoms \texttt{p(1)} and \texttt{p(2)} are included.
The last parity constraint discards any answer set not containing the atom \texttt{p(5)}.

\xorro{} handles parity constraints in six different ways as shown in Table~\ref{table:xorro_approaches}, 
where the first three corresponds to ASP encodings of parity constraints (eager approaches), and the last three to theory propagators within \clingo{}'s Python interface (lazy approaches).~\footnote{The distinction of eager and lazy approaches follows the methodology in Satisfiability modulo theories~\cite{baseseti09a}.}




\begin{table*}[t]
	% 	\centering
	\caption{\xorro{} approaches to handle parity constraints}\label{table:xorro_approaches}
	%\vspace{-5mm}
	\begin{tabular}{ l|l }
		Approach  & Description  \\
		\hline\hline
		count     & Add count aggregates with a modulo 2 operation  \\  
		list,tree & Translate binary \XOR{} operators into rules forming list and tree structures \\
		%            & (binary operators are arranged in list/tree)\\
		countp    & Propagator simply counting truth literals on total assignments\\
		up        & Propagator implementing unit propagation\\
		gje       & Propagator implementing (non-incremental) Gauss-Jordan Elimination
		
	\end{tabular}
	%	\vspace{-7mm}
\end{table*}
%

\section{Hashing and Xor's} \label{sec:hashing}
Apriori we do not know the distribution of the solution set; $Sol(\phi)$. 
%
How to perform a good hashing if we have no knowledge of the distribution of solutions? i.e., how to partition the $Sol(\phi)$ into cells with a roughly equal number of solutions?
%
\textbf{Universal hashing}~\cite{DBLP:conf/stoc/CarterW77} comes to our rescue. 
%
%To partition the $Sol(\phi)$ into roughly equal small cells without knowing the distribution of the solution we use universal hashing. 
The idea is: pick a function randomly from a family of hash functions.  By choosing a random hash function from a family, we randomize over arbitrary input distribution. This guarantees a low number of collisions in expectation irrespective of how data is chosen.
%

\begin{definition}
A family of functions $\mathcal{H}=\{h: U \to [m]\}$  is called a universal family if, 
\[ \forall x,y\in U,~x\neq y:~~\Pr _{h\in H}[h(x)=h(y)]\leq {\frac {1}{m}} \]	
\end{definition}

For model counting with high guarantees this is not enough, we not only need every input to be hash uniformly but also hashed independently. We need a family of $k$-wise independent hash functions~\cite{DBLP:conf/focs/WegmanC79},
%
%$H(n, m, k)$: 
%Need Family of $k$-wise independent hash functions mapping $\{0, 1\}^{U}$
% $\to$ $\{0, 1\}^{m}$ such that every $k$ elements are mapped independently.
formally, 
a family $\mathcal{H} = {h : U \to [m]}$ of hash functions
is $k$-wise independent if:
\begin{enumerate}
	\item For any distinct keys $x_1, ..., x_k \in U$, the hash codes
	$h(x_1), ..., h(x_k)$ are independent random variables.
	\item For any fixed $x$, $h(x)$ is uniformly distributed in [m].
\end{enumerate}

Technical definition generally used for the $k$-wise independent:
% i.e.,  A random hash function $h$ is $k$-independent iffor all choices of distinct $x_1$,…,$x_k$ the values $h(x_1)$,…,$h(x_k)$ are independent.
\begin{definition}
	Let $\mathcal{H}=\{h: U \to [m]\}$ be a family of hash functions. For any distinct $x_1$, . . . , $x_k \in U$ and any $y_1$, ..., $y_k \in [m]$ we have the following guarantee.
	
	$~~\Pr_{h\in H}
	[h(x_1) = y_1 \land ... \land h(x_k) = y_k] = \frac {1}
	{m^
		k}$
\end{definition}

Higher the $k$, stronger will be the guarantee on a range of the size of cells. To encode $k$-wise independence we will require polynomial of degree $k$ - $1$. But higher the $k$, harder it will be to solve the formula with these constraints. Due to this trade-off we just use 3-wise independent. If we use $k$-wise independence, all cells will be  small and we will get a \textbf{uniform generation}. With $3$-wise independence we achieve: \emph{a random cell is small with high probabablity}, also called \textbf{almost-uniform generation}.


The canonical construction of a $k$-wise independent family is based on polynomials
of degree $k$ - $1$. Let $p \geq |U|$ be prime. Picking random $a_0,...,a_{k - 1} \in \{0, . . . , p$-$ 1\}$,
the hash function is defined by:
\[ h(x) = ( ( a_{k-1} x^ {k - 1} + ... + a_1 x + a_0) \,\, mod \,\, p) \,\, mod \,\,  m\]


For $p \gg	 m$, the hash function is statistically close to $k$-wise independent.

The 2-wise independent hash is: 

\[ h(x) = (((a_1 x + a_0) \,\, mod \,\, p) \,\, mod \,\, m ) \]

\section{ApproxASP} \label{approxasp}
\textbf{ApproxMC Algorithm into ASP}

\begin{algorithm}[h]
	\textbf{ApproxASP}($F$, $\epsilon$, $\delta$) \;
	\SetAlgoLined
	\KwResult{Approximate number of answer sets or $\bot$}
	$counter \gets 0$ ; $C \gets emptyList$\;
	$pivot \gets  2 \, \times $ \textbf{ComputeThreshold($\epsilon$)} \;
	$S \gets Xampler(F, pivot + 1)$ // {Solve pivot+1 AS}  \;
	\eIf{ $|S| \leq pivot$}
	{ % Open If
		\textbf{return} $|S|$ 
	} % Close If
	{ % Open Else
		$t \gets $ \textbf{ComputeIterCount($\delta$)} 
		
		\While{$counter < t$}{
			$c \gets $ \textbf{ApproxASPCore($F, pivot$)} \;
			$counter \gets counter + 1$ \;
			\If{$c \neq \bot$}{\textbf{AddToList($C,c$)}}
		} % Close While
	} % Close else
	$finalCount \gets $ \textbf{FindMedian($C$)} \;
	\textbf{return} $finalCount$
	
	\caption{ApproxMC into ASP}
\end{algorithm}


\begin{algorithm}
	\textbf{return} $\lceil 3 e^{1/2} (1 + \frac{1}{\epsilon})^2 \rceil$
	\caption{ComputeThreshold($\epsilon$)}
\end{algorithm}

\begin{algorithm}
	\textbf{return} $\lceil 35 \log_2 (3/\delta) \rceil$
	\caption{ComputeIterCount($\delta$)}
\end{algorithm}

\begin{algorithm}
	/* Assume $z_1 , ..., z_n $ are the varaibles of $F$ */ \\
	$ i, l \gets \lfloor \log_2 (pivot) - 1 \rfloor$ \\
%	$ i \gets l - 1$ \\
	
	\While{($1 \leq |S| \leq pivot $) or ($i = n$)}{
		$ i \gets i + 1$ \\
		Choose $h$ at random from $H_{xor}(n, i - l, 3)$ \\
		Choose $\alpha$ at random from $\{0,1\}^{i-l}$ \\
		$S \gets Xampler(F \land (h(z_1, ..., z_n)=\alpha, pivot + 1)$ %\Comment*[r]{Solve $P \land XOR$}  
	}
	
	\eIf{ $|S|$ $> pivot$ or $|S|$ = 0}
	{\textbf{return} $\bot$}
	{\textbf{return} $|S|$ $\cdot 2^{i-l}$}
	
	
	
	\caption{ApproxASPCore($F, pivot$)}
\end{algorithm}


\input{experiments}

\section{Conclusion} \label{sec:conclusion}
XXX

%% The file kr.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{kr}
\bibliography{NMR2020}

\end{document}

